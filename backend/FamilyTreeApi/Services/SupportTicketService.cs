using FamilyTreeApi.Data;
using FamilyTreeApi.DTOs;
using FamilyTreeApi.Models;
using FamilyTreeApi.Models.Enums;
using Microsoft.AspNetCore.Http;
using Microsoft.EntityFrameworkCore;

namespace FamilyTreeApi.Services;

/// <summary>
/// Platform-level support ticket service. No OrgId â€” not tree-scoped.
/// Uses VirtualUpon.Storage for attachment file uploads.
/// </summary>
public class SupportTicketService : ISupportTicketService
{
    private readonly ApplicationDbContext _context;
    private readonly VirtualUpon.Storage.Factories.IStorageService _storageService;
    private readonly ILogger<SupportTicketService> _logger;

    private static readonly string[] AllowedImageTypes = { "image/jpeg", "image/png", "image/gif", "image/webp" };
    private const long MaxAttachmentSizeBytes = 10 * 1024 * 1024; // 10MB
    private const int MaxAttachmentsPerTicket = 5;

    public SupportTicketService(
        ApplicationDbContext context,
        VirtualUpon.Storage.Factories.IStorageService storageService,
        ILogger<SupportTicketService> logger)
    {
        _context = context;
        _storageService = storageService;
        _logger = logger;
    }

    // ============================================================================
    // User Operations
    // ============================================================================

    public async Task<ServiceResult<SupportTicketDetailDto>> CreateTicketAsync(
        CreateSupportTicketRequest request,
        long userId,
        CancellationToken cancellationToken = default)
    {
        try
        {
            var ticket = new SupportTicket
            {
                Category = request.Category,
                Priority = TicketPriority.Medium, // default; admin can adjust later
                Status = TicketStatus.Open,
                Subject = request.Subject.Trim(),
                Description = request.Description.Trim(),
                StepsToReproduce = request.StepsToReproduce?.Trim(),
                PageUrl = request.PageUrl,
                BrowserInfo = request.BrowserInfo,
                SubmittedByUserId = userId,
                SubmittedAt = DateTime.UtcNow
            };

            _context.SupportTickets.Add(ticket);
            await _context.SaveChangesAsync(cancellationToken);

            // Re-fetch with includes to get TicketNumber (generated by DB)
            return await GetTicketAsync(ticket.Id, userId, false, cancellationToken);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error creating support ticket for user {UserId}", userId);
            return ServiceResult<SupportTicketDetailDto>.InternalError("Failed to create ticket");
        }
    }

    public async Task<ServiceResult<PagedResult<SupportTicketSummaryDto>>> GetMyTicketsAsync(
        long userId,
        SupportTicketQueryParams queryParams,
        CancellationToken cancellationToken = default)
    {
        try
        {
            var query = _context.SupportTickets
                .AsNoTracking()
                .Where(t => t.SubmittedByUserId == userId);

            query = ApplyFilters(query, queryParams);
            query = ApplySorting(query, queryParams);

            var totalCount = await query.CountAsync(cancellationToken);

            var page = Math.Max(1, queryParams.Page);
            var pageSize = Math.Clamp(queryParams.PageSize, 1, 100);

            var tickets = await query
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .Include(t => t.SubmittedByUser)
                .Include(t => t.AssignedToUser)
                .Include(t => t.Attachments)
                .Include(t => t.Comments)
                .ToListAsync(cancellationToken);

            var items = tickets.Select(MapToSummary).ToList();

            return ServiceResult<PagedResult<SupportTicketSummaryDto>>.Success(
                new PagedResult<SupportTicketSummaryDto>(
                    items, totalCount, page, pageSize,
                    (int)Math.Ceiling((double)totalCount / pageSize)));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting tickets for user {UserId}", userId);
            return ServiceResult<PagedResult<SupportTicketSummaryDto>>.InternalError("Failed to load tickets");
        }
    }

    public async Task<ServiceResult<SupportTicketDetailDto>> GetTicketAsync(
        Guid id,
        long userId,
        bool isAdmin,
        CancellationToken cancellationToken = default)
    {
        try
        {
            var ticket = await _context.SupportTickets
                .AsNoTracking()
                .Include(t => t.SubmittedByUser)
                .Include(t => t.AssignedToUser)
                .Include(t => t.ResolvedByUser)
                .Include(t => t.Attachments)
                .Include(t => t.Comments.Where(c => !c.IsDeleted).OrderBy(c => c.CreatedAt))
                    .ThenInclude(c => c.AuthorUser)
                .FirstOrDefaultAsync(t => t.Id == id, cancellationToken);

            if (ticket == null)
                return ServiceResult<SupportTicketDetailDto>.NotFound("Ticket not found");

            // Access check: submitter can see own, admin sees all
            if (!isAdmin && ticket.SubmittedByUserId != userId)
                return ServiceResult<SupportTicketDetailDto>.Forbidden("Access denied");

            var dto = MapToDetail(ticket, isAdmin);
            return ServiceResult<SupportTicketDetailDto>.Success(dto);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting ticket {TicketId}", id);
            return ServiceResult<SupportTicketDetailDto>.InternalError("Failed to load ticket");
        }
    }

    public async Task<ServiceResult<TicketAttachmentDto>> AddAttachmentAsync(
        Guid ticketId,
        IFormFile file,
        long userId,
        bool isAdmin,
        CancellationToken cancellationToken = default)
    {
        try
        {
            var ticket = await _context.SupportTickets
                .AsTracking()
                .Include(t => t.Attachments)
                .FirstOrDefaultAsync(t => t.Id == ticketId, cancellationToken);

            if (ticket == null)
                return ServiceResult<TicketAttachmentDto>.NotFound("Ticket not found");

            // Access: submitter or admin
            if (!isAdmin && ticket.SubmittedByUserId != userId)
                return ServiceResult<TicketAttachmentDto>.Forbidden("Access denied");

            // Validate attachment count
            if (ticket.Attachments.Count >= MaxAttachmentsPerTicket)
                return ServiceResult<TicketAttachmentDto>.Failure(
                    $"Maximum {MaxAttachmentsPerTicket} attachments per ticket");

            // Validate file type
            if (!AllowedImageTypes.Contains(file.ContentType.ToLowerInvariant()))
                return ServiceResult<TicketAttachmentDto>.Failure(
                    "Only image files are allowed (JPEG, PNG, GIF, WebP)");

            // Validate file size
            if (file.Length > MaxAttachmentSizeBytes)
                return ServiceResult<TicketAttachmentDto>.Failure(
                    $"File too large. Maximum size is {MaxAttachmentSizeBytes / (1024 * 1024)}MB");

            if (file.Length == 0)
                return ServiceResult<TicketAttachmentDto>.Failure("File is empty");

            // Read file bytes and upload to storage
            using var memoryStream = new MemoryStream();
            await file.CopyToAsync(memoryStream, cancellationToken);
            var fileBytes = memoryStream.ToArray();

            var extension = Path.GetExtension(file.FileName);
            var uniqueFileName = $"{Guid.NewGuid()}{extension}";
            var pathSegments = new[] { "support-tickets", ticketId.ToString() };

            var savedInfo = await _storageService.UploadFileAsync(pathSegments, uniqueFileName, fileBytes);

            var storageKey = string.Join("/", pathSegments.Append(uniqueFileName));

            var attachment = new SupportTicketAttachment
            {
                TicketId = ticketId,
                FileName = file.FileName,
                StorageKey = storageKey,
                Url = savedInfo.ImagePath,
                MimeType = file.ContentType,
                FileSize = file.Length,
                UploadedByUserId = userId
            };

            _context.SupportTicketAttachments.Add(attachment);
            ticket.UpdatedAt = DateTime.UtcNow;
            await _context.SaveChangesAsync(cancellationToken);

            return ServiceResult<TicketAttachmentDto>.Success(new TicketAttachmentDto(
                attachment.Id,
                attachment.FileName,
                attachment.Url,
                attachment.MimeType,
                attachment.FileSize,
                attachment.UploadedByUserId,
                attachment.CreatedAt));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error adding attachment to ticket {TicketId}", ticketId);
            return ServiceResult<TicketAttachmentDto>.InternalError("Failed to upload attachment");
        }
    }

    public async Task<ServiceResult<TicketCommentDto>> AddCommentAsync(
        Guid ticketId,
        AddTicketCommentRequest request,
        long userId,
        bool isAdmin,
        CancellationToken cancellationToken = default)
    {
        try
        {
            var ticket = await _context.SupportTickets
                .AsTracking()
                .FirstOrDefaultAsync(t => t.Id == ticketId, cancellationToken);

            if (ticket == null)
                return ServiceResult<TicketCommentDto>.NotFound("Ticket not found");

            // Access: submitter or admin
            if (!isAdmin && ticket.SubmittedByUserId != userId)
                return ServiceResult<TicketCommentDto>.Forbidden("Access denied");

            var comment = new SupportTicketComment
            {
                TicketId = ticketId,
                Content = request.Content.Trim(),
                IsAdminResponse = isAdmin,
                AuthorUserId = userId
            };

            _context.SupportTicketComments.Add(comment);
            ticket.UpdatedAt = DateTime.UtcNow;
            await _context.SaveChangesAsync(cancellationToken);

            // Get author name
            var author = await _context.Users
                .AsNoTracking()
                .FirstOrDefaultAsync(u => u.Id == userId, cancellationToken);

            return ServiceResult<TicketCommentDto>.Success(new TicketCommentDto(
                comment.Id,
                comment.Content,
                comment.IsAdminResponse,
                comment.AuthorUserId,
                GetUserDisplayName(author),
                comment.CreatedAt));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error adding comment to ticket {TicketId}", ticketId);
            return ServiceResult<TicketCommentDto>.InternalError("Failed to add comment");
        }
    }

    // ============================================================================
    // Admin Operations
    // ============================================================================

    public async Task<ServiceResult<PagedResult<SupportTicketSummaryDto>>> GetAllTicketsAsync(
        SupportTicketQueryParams queryParams,
        CancellationToken cancellationToken = default)
    {
        try
        {
            var query = _context.SupportTickets.AsNoTracking();

            query = ApplyFilters(query, queryParams);
            query = ApplySorting(query, queryParams);

            var totalCount = await query.CountAsync(cancellationToken);

            var page = Math.Max(1, queryParams.Page);
            var pageSize = Math.Clamp(queryParams.PageSize, 1, 100);

            var tickets = await query
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .Include(t => t.SubmittedByUser)
                .Include(t => t.AssignedToUser)
                .Include(t => t.Attachments)
                .Include(t => t.Comments)
                .ToListAsync(cancellationToken);

            var items = tickets.Select(MapToSummary).ToList();

            return ServiceResult<PagedResult<SupportTicketSummaryDto>>.Success(
                new PagedResult<SupportTicketSummaryDto>(
                    items, totalCount, page, pageSize,
                    (int)Math.Ceiling((double)totalCount / pageSize)));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting all tickets");
            return ServiceResult<PagedResult<SupportTicketSummaryDto>>.InternalError("Failed to load tickets");
        }
    }

    public async Task<ServiceResult<SupportTicketDetailDto>> UpdateStatusAsync(
        Guid id,
        UpdateTicketStatusRequest request,
        long adminUserId,
        CancellationToken cancellationToken = default)
    {
        try
        {
            var ticket = await _context.SupportTickets
                .AsTracking()
                .FirstOrDefaultAsync(t => t.Id == id, cancellationToken);

            if (ticket == null)
                return ServiceResult<SupportTicketDetailDto>.NotFound("Ticket not found");

            ticket.Status = request.Status;
            ticket.UpdatedAt = DateTime.UtcNow;

            // Auto-set resolution fields when resolving
            if (request.Status == TicketStatus.Resolved)
            {
                ticket.ResolvedAt = DateTime.UtcNow;
                ticket.ResolvedByUserId = adminUserId;
                ticket.ResolutionNotes = request.ResolutionNotes?.Trim();
            }
            else if (request.Status == TicketStatus.Open)
            {
                // Re-opening: clear resolution
                ticket.ResolvedAt = null;
                ticket.ResolvedByUserId = null;
                ticket.ResolutionNotes = null;
            }

            await _context.SaveChangesAsync(cancellationToken);

            return await GetTicketAsync(id, adminUserId, true, cancellationToken);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating status for ticket {TicketId}", id);
            return ServiceResult<SupportTicketDetailDto>.InternalError("Failed to update status");
        }
    }

    public async Task<ServiceResult<SupportTicketDetailDto>> AssignTicketAsync(
        Guid id,
        AssignTicketRequest request,
        long adminUserId,
        CancellationToken cancellationToken = default)
    {
        try
        {
            var ticket = await _context.SupportTickets
                .AsTracking()
                .FirstOrDefaultAsync(t => t.Id == id, cancellationToken);

            if (ticket == null)
                return ServiceResult<SupportTicketDetailDto>.NotFound("Ticket not found");

            // Verify assignee exists
            var assignee = await _context.Users
                .AsNoTracking()
                .FirstOrDefaultAsync(u => u.Id == request.AssignedToUserId, cancellationToken);

            if (assignee == null)
                return ServiceResult<SupportTicketDetailDto>.Failure("Assignee user not found");

            ticket.AssignedToUserId = request.AssignedToUserId;
            ticket.AssignedAt = DateTime.UtcNow;
            ticket.UpdatedAt = DateTime.UtcNow;

            await _context.SaveChangesAsync(cancellationToken);

            return await GetTicketAsync(id, adminUserId, true, cancellationToken);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error assigning ticket {TicketId}", id);
            return ServiceResult<SupportTicketDetailDto>.InternalError("Failed to assign ticket");
        }
    }

    public async Task<ServiceResult<SupportTicketDetailDto>> UpdatePriorityAsync(
        Guid id,
        UpdateTicketPriorityRequest request,
        long adminUserId,
        CancellationToken cancellationToken = default)
    {
        try
        {
            var ticket = await _context.SupportTickets
                .AsTracking()
                .FirstOrDefaultAsync(t => t.Id == id, cancellationToken);

            if (ticket == null)
                return ServiceResult<SupportTicketDetailDto>.NotFound("Ticket not found");

            ticket.Priority = request.Priority;
            ticket.UpdatedAt = DateTime.UtcNow;

            await _context.SaveChangesAsync(cancellationToken);

            return await GetTicketAsync(id, adminUserId, true, cancellationToken);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating priority for ticket {TicketId}", id);
            return ServiceResult<SupportTicketDetailDto>.InternalError("Failed to update priority");
        }
    }

    public async Task<ServiceResult<SupportTicketDetailDto>> UpdateAdminNotesAsync(
        Guid id,
        UpdateAdminNotesRequest request,
        long adminUserId,
        CancellationToken cancellationToken = default)
    {
        try
        {
            var ticket = await _context.SupportTickets
                .AsTracking()
                .FirstOrDefaultAsync(t => t.Id == id, cancellationToken);

            if (ticket == null)
                return ServiceResult<SupportTicketDetailDto>.NotFound("Ticket not found");

            ticket.AdminNotes = request.AdminNotes?.Trim();
            ticket.UpdatedAt = DateTime.UtcNow;

            await _context.SaveChangesAsync(cancellationToken);

            return await GetTicketAsync(id, adminUserId, true, cancellationToken);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating admin notes for ticket {TicketId}", id);
            return ServiceResult<SupportTicketDetailDto>.InternalError("Failed to update admin notes");
        }
    }

    public async Task<ServiceResult> DeleteTicketAsync(
        Guid id,
        long adminUserId,
        CancellationToken cancellationToken = default)
    {
        try
        {
            var ticket = await _context.SupportTickets
                .AsTracking()
                .FirstOrDefaultAsync(t => t.Id == id, cancellationToken);

            if (ticket == null)
                return ServiceResult.NotFound("Ticket not found");

            ticket.IsDeleted = true;
            ticket.DeletedAt = DateTime.UtcNow;
            ticket.DeletedByUserId = adminUserId;

            await _context.SaveChangesAsync(cancellationToken);

            return ServiceResult.Success();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error deleting ticket {TicketId}", id);
            return ServiceResult.InternalError("Failed to delete ticket");
        }
    }

    public async Task<ServiceResult<SupportTicketStatsDto>> GetStatsAsync(
        CancellationToken cancellationToken = default)
    {
        try
        {
            var tickets = _context.SupportTickets.AsNoTracking();

            var totalCount = await tickets.CountAsync(cancellationToken);
            var openCount = await tickets.CountAsync(t => t.Status == TicketStatus.Open, cancellationToken);
            var workingCount = await tickets.CountAsync(t => t.Status == TicketStatus.WorkingOnIt, cancellationToken);
            var resolvedCount = await tickets.CountAsync(t => t.Status == TicketStatus.Resolved, cancellationToken);
            var closedCount = await tickets.CountAsync(t => t.Status == TicketStatus.Closed, cancellationToken);

            // Average resolution time for resolved/closed tickets
            double? avgHours = null;
            var resolvedTickets = await tickets
                .Where(t => t.ResolvedAt != null && (t.Status == TicketStatus.Resolved || t.Status == TicketStatus.Closed))
                .Select(t => new { t.SubmittedAt, t.ResolvedAt })
                .ToListAsync(cancellationToken);

            if (resolvedTickets.Count > 0)
            {
                avgHours = resolvedTickets
                    .Average(t => (t.ResolvedAt!.Value - t.SubmittedAt).TotalHours);
                avgHours = Math.Round(avgHours.Value, 1);
            }

            return ServiceResult<SupportTicketStatsDto>.Success(
                new SupportTicketStatsDto(
                    totalCount, openCount, workingCount, resolvedCount, closedCount, avgHours));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting ticket statistics");
            return ServiceResult<SupportTicketStatsDto>.InternalError("Failed to load statistics");
        }
    }

    // ============================================================================
    // Private Helpers
    // ============================================================================

    private static string GetUserDisplayName(ApplicationUser? user)
    {
        if (user == null) return "Unknown";
        var fullName = $"{user.FirstName} {user.LastName}".Trim();
        return string.IsNullOrEmpty(fullName) ? user.UserName ?? "Unknown" : fullName;
    }

    private static IQueryable<SupportTicket> ApplyFilters(
        IQueryable<SupportTicket> query, SupportTicketQueryParams p)
    {
        if (p.Category.HasValue)
            query = query.Where(t => t.Category == p.Category.Value);

        if (p.Priority.HasValue)
            query = query.Where(t => t.Priority == p.Priority.Value);

        if (p.Status.HasValue)
            query = query.Where(t => t.Status == p.Status.Value);

        if (p.AssignedToUserId.HasValue)
            query = query.Where(t => t.AssignedToUserId == p.AssignedToUserId.Value);

        if (!string.IsNullOrWhiteSpace(p.SearchTerm))
        {
            var term = p.SearchTerm.Trim().ToLower();
            query = query.Where(t =>
                t.Subject.ToLower().Contains(term) ||
                t.Description.ToLower().Contains(term));
        }

        return query;
    }

    private static IQueryable<SupportTicket> ApplySorting(
        IQueryable<SupportTicket> query, SupportTicketQueryParams p)
    {
        return p.SortBy?.ToLower() switch
        {
            "ticketnumber" => p.SortDesc
                ? query.OrderByDescending(t => t.TicketNumber)
                : query.OrderBy(t => t.TicketNumber),
            "status" => p.SortDesc
                ? query.OrderByDescending(t => t.Status)
                : query.OrderBy(t => t.Status),
            "priority" => p.SortDesc
                ? query.OrderByDescending(t => t.Priority)
                : query.OrderBy(t => t.Priority),
            "subject" => p.SortDesc
                ? query.OrderByDescending(t => t.Subject)
                : query.OrderBy(t => t.Subject),
            _ => p.SortDesc
                ? query.OrderByDescending(t => t.CreatedAt)
                : query.OrderBy(t => t.CreatedAt)
        };
    }

    private static SupportTicketSummaryDto MapToSummary(SupportTicket t) => new(
        t.Id,
        t.TicketNumber,
        t.Category,
        t.Priority,
        t.Status,
        t.Subject,
        t.SubmittedAt,
        t.SubmittedByUserId,
        GetUserDisplayName(t.SubmittedByUser),
        t.SubmittedByUser?.Email,
        t.AssignedToUserId,
        t.AssignedToUser != null ? GetUserDisplayName(t.AssignedToUser) : null,
        t.Attachments?.Count ?? 0,
        t.Comments?.Count(c => !c.IsDeleted) ?? 0,
        t.ResolvedAt,
        t.CreatedAt,
        t.UpdatedAt
    );

    private static SupportTicketDetailDto MapToDetail(SupportTicket t, bool isAdmin) => new(
        t.Id,
        t.TicketNumber,
        t.Category,
        t.Priority,
        t.Status,
        t.Subject,
        t.Description,
        t.StepsToReproduce,
        t.PageUrl,
        t.BrowserInfo,
        t.SubmittedAt,
        t.SubmittedByUserId,
        GetUserDisplayName(t.SubmittedByUser),
        t.SubmittedByUser?.Email,
        t.AssignedToUserId,
        t.AssignedToUser != null ? GetUserDisplayName(t.AssignedToUser) : null,
        isAdmin ? t.AdminNotes : null,  // SECURITY: hide admin notes from non-admins
        t.ResolvedAt,
        t.ResolvedByUserId,
        t.ResolvedByUser != null ? GetUserDisplayName(t.ResolvedByUser) : null,
        t.ResolutionNotes,
        t.CreatedAt,
        t.UpdatedAt,
        t.Attachments?.Select(a => new TicketAttachmentDto(
            a.Id, a.FileName, a.Url, a.MimeType, a.FileSize,
            a.UploadedByUserId, a.CreatedAt)).ToList() ?? new(),
        t.Comments?.Where(c => !c.IsDeleted).OrderBy(c => c.CreatedAt).Select(c => new TicketCommentDto(
            c.Id, c.Content, c.IsAdminResponse, c.AuthorUserId,
            GetUserDisplayName(c.AuthorUser),
            c.CreatedAt)).ToList() ?? new()
    );
}
