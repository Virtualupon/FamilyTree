# Implementation Plan: Registration Enhancement (REVISED)

## Overview
Enhance the registration flow with:
1. **HomeTown Selection** (optional) - "Where are you from?" field
2. **Email Verification** - 6-digit code verification before account activation
3. **Forgot Password Flow** - Reset password using 6-digit code

---

## ⚠️ DOCUMENTED ASSUMPTIONS

| # | Assumption | Enforcement |
|---|------------|-------------|
| 1 | Email delivery may fail | Retry mechanism + queue for reliability |
| 2 | Servers are NTP-synced | Document in deployment requirements |
| 3 | Multi-instance deployment | Use Redis for distributed rate limiting |
| 4 | Email is case-insensitive | Normalize to lowercase before all operations |
| 5 | Users cannot change email after registration | Email change requires re-verification (future scope) |
| 6 | Concurrent registration possible | Unique constraint on normalized email |
| 7 | Towns list < 1000 | No pagination needed for registration dropdown |

---

## Phase 1: Database Changes

### 1.1 Add `HomeTownId` to `AspNetUsers` table
```sql
ALTER TABLE "AspNetUsers"
ADD COLUMN "HomeTownId" uuid NULL;

ALTER TABLE "AspNetUsers"
ADD CONSTRAINT "FK_AspNetUsers_HomeTown"
FOREIGN KEY ("HomeTownId") REFERENCES "Towns"("Id") ON DELETE SET NULL;

CREATE INDEX "IX_AspNetUsers_HomeTownId" ON "AspNetUsers"("HomeTownId");
```

### 1.2 Create `EmailVerificationCodes` table
```sql
CREATE TABLE "EmailVerificationCodes" (
    "Id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "Email" varchar(256) NOT NULL,           -- Normalized lowercase email
    "UserId" bigint NULL,                     -- NULL for pre-registration codes
    "Code" varchar(6) NOT NULL,
    "Purpose" varchar(20) NOT NULL,           -- 'Registration' or 'PasswordReset'
    "CreatedAt" timestamptz NOT NULL DEFAULT now(),
    "ExpiresAt" timestamptz NOT NULL,
    "IsUsed" boolean NOT NULL DEFAULT false,
    "UsedAt" timestamptz NULL,
    "AttemptCount" integer NOT NULL DEFAULT 0, -- Track failed attempts per code
    "IpAddress" varchar(45) NULL,             -- For rate limiting auditing
    "RowVersion" integer NOT NULL DEFAULT 1,  -- Optimistic concurrency
    CONSTRAINT "FK_EmailVerificationCodes_User" FOREIGN KEY ("UserId")
        REFERENCES "AspNetUsers"("Id") ON DELETE CASCADE
);

CREATE INDEX "IX_EmailVerificationCodes_Email_Purpose" ON "EmailVerificationCodes"("Email", "Purpose");
CREATE INDEX "IX_EmailVerificationCodes_ExpiresAt" ON "EmailVerificationCodes"("ExpiresAt");
CREATE INDEX "IX_EmailVerificationCodes_CreatedAt" ON "EmailVerificationCodes"("CreatedAt");

-- Cleanup job: Delete expired codes older than 24 hours
-- Run daily via pg_cron or application background service
```

### 1.3 Create Rate Limiting Support Table (Redis Primary, DB Fallback)
```sql
CREATE TABLE "RateLimitEntries" (
    "Id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "Key" varchar(256) NOT NULL,              -- e.g., "email:verify:user@example.com" or "ip:register:192.168.1.1"
    "Count" integer NOT NULL DEFAULT 1,
    "WindowStart" timestamptz NOT NULL,
    "WindowEnd" timestamptz NOT NULL,
    CONSTRAINT "UQ_RateLimitEntries_Key" UNIQUE ("Key")
);

CREATE INDEX "IX_RateLimitEntries_WindowEnd" ON "RateLimitEntries"("WindowEnd");
```

**Files to modify:**
- `backend/FamilyTreeApi/Models/ApplicationUser.cs` - Add `HomeTownId` property
- `backend/FamilyTreeApi/Models/EmailVerificationCode.cs` - **NEW FILE**
- `backend/FamilyTreeApi/Models/RateLimitEntry.cs` - **NEW FILE**
- `backend/FamilyTreeApi/Data/ApplicationDbContext.cs` - Add DbSet and configure relationships
- `DB/migration_email_verification.sql` - **NEW FILE**

---

## Phase 2: Backend - Models & DTOs

### 2.1 Update `ApplicationUser.cs`
```csharp
// Add to ApplicationUser class:

/// <summary>
/// User's home town (where they are from). Optional field for access control.
/// </summary>
public Guid? HomeTownId { get; set; }
public Town? HomeTown { get; set; }
```

### 2.2 Create `EmailVerificationCode.cs` model
```csharp
public class EmailVerificationCode
{
    public long Id { get; set; }

    [Required]
    [MaxLength(256)]
    public string Email { get; set; } = string.Empty;  // Normalized lowercase

    public long? UserId { get; set; }  // NULL for pre-registration (two-phase)
    public ApplicationUser? User { get; set; }

    [Required]
    [MaxLength(6)]
    public string Code { get; set; } = string.Empty;

    [Required]
    [MaxLength(20)]
    public string Purpose { get; set; } = string.Empty;  // "Registration" or "PasswordReset"

    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime ExpiresAt { get; set; }
    public bool IsUsed { get; set; }
    public DateTime? UsedAt { get; set; }
    public int AttemptCount { get; set; }  // Failed verification attempts

    [MaxLength(45)]
    public string? IpAddress { get; set; }

    // Optimistic concurrency
    [ConcurrencyCheck]
    public int RowVersion { get; set; } = 1;
}

public enum VerificationPurpose
{
    Registration,
    PasswordReset
}
```

### 2.3 Update `AuthDTOs.cs`
```csharp
// ============================================================================
// Registration DTOs (Two-Phase)
// ============================================================================

/// <summary>
/// Phase 1: Initiate registration - validates email and sends code
/// User record is NOT created yet
/// </summary>
public record InitiateRegistrationRequest(
    string Email,
    string Password,
    string? FirstName,
    string? LastName,
    Guid? HomeTownId
);

/// <summary>
/// Response for initiation - ALWAYS returns success to prevent enumeration
/// </summary>
public record InitiateRegistrationResponse(
    bool Success,
    string Message,
    string Email  // Masked: j***@example.com
);

/// <summary>
/// Phase 2: Complete registration - verify code and create user
/// </summary>
public record CompleteRegistrationRequest(
    string Email,
    string Code,
    string Password,
    string? FirstName,
    string? LastName,
    Guid? HomeTownId
);

/// <summary>
/// Response with tokens after successful verification
/// </summary>
public record CompleteRegistrationResponse(
    bool Success,
    string Message,
    TokenResponse? Tokens
);

// ============================================================================
// Email Verification DTOs
// ============================================================================

public record VerifyEmailRequest(string Email, string Code);
public record VerifyEmailResponse(bool Success, string Message, TokenResponse? Tokens);

public record ResendCodeRequest(string Email, string Purpose);
public record ResendCodeResponse(bool Success, string Message, int? RetryAfterSeconds);

// ============================================================================
// Password Reset DTOs
// ============================================================================

public record ForgotPasswordRequest(string Email);
/// <summary>
/// ALWAYS returns success to prevent email enumeration
/// </summary>
public record ForgotPasswordResponse(bool Success, string Message);

public record ResetPasswordRequest(string Email, string Code, string NewPassword);
public record ResetPasswordResponse(bool Success, string Message);

// ============================================================================
// Updated UserDto
// ============================================================================

public record UserDto(
    long Id,
    string Email,
    string? FirstName,
    string? LastName,
    bool EmailConfirmed,
    Guid? OrgId,
    string? OrgName,
    int Role,
    string SystemRole = "User",
    string PreferredLanguage = "en",
    bool IsFirstLogin = true,
    Guid? SelectedTownId = null,
    string? SelectedTownName = null,
    Guid? HomeTownId = null,
    string? HomeTownName = null
);
```

**Files to modify:**
- `backend/FamilyTreeApi/Models/ApplicationUser.cs`
- `backend/FamilyTreeApi/Models/EmailVerificationCode.cs` - **NEW FILE**
- `backend/FamilyTreeApi/DTOs/AuthDTOs.cs`

---

## Phase 3: Backend - Rate Limiting Service (Redis-Based)

### 3.1 Create Rate Limiting Service
**NEW FILES:**
- `backend/FamilyTreeApi/Services/IRateLimitService.cs`
- `backend/FamilyTreeApi/Services/RateLimitService.cs`

```csharp
public interface IRateLimitService
{
    /// <summary>
    /// Check if action is allowed and increment counter
    /// </summary>
    Task<RateLimitResult> CheckAndIncrementAsync(string key, int maxAttempts, TimeSpan window);

    /// <summary>
    /// Reset rate limit for a key (e.g., after successful verification)
    /// </summary>
    Task ResetAsync(string key);
}

public record RateLimitResult(
    bool IsAllowed,
    int CurrentCount,
    int MaxAttempts,
    int? RetryAfterSeconds
);

public class RateLimitService : IRateLimitService
{
    private readonly IDistributedCache _cache;  // Redis
    private readonly ILogger<RateLimitService> _logger;

    // Implementation uses Redis INCR with EXPIRE for atomic operations
    // Falls back to database if Redis unavailable
}
```

### 3.2 Rate Limit Configuration
```csharp
public class RateLimitConfiguration
{
    // Per-email limits
    public int MaxCodesPerEmailPerDay { get; set; } = 10;
    public int MaxVerificationAttemptsPerCode { get; set; } = 5;
    public int ResendCooldownSeconds { get; set; } = 60;

    // Per-IP limits (brute force protection)
    public int MaxRegistrationsPerIpPerHour { get; set; } = 10;
    public int MaxVerificationAttemptsPerIpPerHour { get; set; } = 30;
    public int MaxForgotPasswordPerIpPerHour { get; set; } = 10;

    // Global limits
    public int MaxFailedAttemptsBeforeAccountLock { get; set; } = 15;  // Across all codes
    public TimeSpan AccountLockDuration { get; set; } = TimeSpan.FromHours(1);
}
```

**Files to create:**
- `backend/FamilyTreeApi/Services/IRateLimitService.cs` - **NEW FILE**
- `backend/FamilyTreeApi/Services/RateLimitService.cs` - **NEW FILE**
- `backend/FamilyTreeApi/Models/Configuration/RateLimitConfiguration.cs` - **NEW FILE**

---

## Phase 4: Backend - Email Service

### 4.1 Create Email Service Interface & Implementation
```csharp
public interface IEmailService
{
    Task<EmailSendResult> SendVerificationCodeAsync(string email, string code, string? userName);
    Task<EmailSendResult> SendPasswordResetCodeAsync(string email, string code, string? userName);
}

public record EmailSendResult(bool Success, string? ErrorMessage);

public class EmailService : IEmailService
{
    private readonly EmailConfiguration _config;
    private readonly ILogger<EmailService> _logger;

    // Implementation with:
    // - Retry logic (Polly)
    // - Async fire-and-forget option with logging
    // - Error tracking
}
```

### 4.2 Add Email Configuration
Add to `appsettings.json`:
```json
"EmailSettings": {
    "SmtpHost": "${SMTP_HOST}",
    "SmtpPort": 587,
    "SmtpUsername": "${SMTP_USERNAME}",
    "SmtpPassword": "${SMTP_PASSWORD}",
    "FromEmail": "noreply@familytree.com",
    "FromName": "Family Tree Platform",
    "UseSsl": true,
    "RetryCount": 3,
    "RetryDelaySeconds": 2
}
```

**⚠️ SECURITY: Use environment variables or secrets manager for credentials**

**Files to create:**
- `backend/FamilyTreeApi/Services/IEmailService.cs` - **NEW FILE**
- `backend/FamilyTreeApi/Services/EmailService.cs` - **NEW FILE**
- `backend/FamilyTreeApi/Models/Configuration/EmailConfiguration.cs` - **NEW FILE**

**Files to modify:**
- `backend/FamilyTreeApi/appsettings.json`
- `backend/FamilyTreeApi/Program.cs` - Register services

---

## Phase 5: Backend - Auth Service Updates

### 5.1 Update `IAuthService.cs`
```csharp
// ============================================================================
// Two-Phase Registration
// ============================================================================

/// <summary>
/// Phase 1: Validate email, send verification code
/// Does NOT create user record
/// Returns same response regardless of email existence (prevents enumeration)
/// </summary>
Task<InitiateRegistrationResponse> InitiateRegistrationAsync(
    InitiateRegistrationRequest request,
    string ipAddress);

/// <summary>
/// Phase 2: Verify code and create user
/// Creates user record only after successful verification
/// </summary>
Task<CompleteRegistrationResponse> CompleteRegistrationAsync(
    CompleteRegistrationRequest request,
    string ipAddress);

// ============================================================================
// Email Verification (for existing unverified users - backwards compatibility)
// ============================================================================

Task<VerifyEmailResponse> VerifyEmailAsync(VerifyEmailRequest request, string ipAddress);
Task<ResendCodeResponse> ResendVerificationCodeAsync(string email, string ipAddress);

// ============================================================================
// Password Reset
// ============================================================================

/// <summary>
/// Always returns success to prevent email enumeration
/// Sends email only if account exists
/// </summary>
Task<ForgotPasswordResponse> ForgotPasswordAsync(string email, string ipAddress);

Task<ResetPasswordResponse> ResetPasswordAsync(ResetPasswordRequest request, string ipAddress);
```

### 5.2 Update `AuthService.cs` - Key Implementation Details

#### Two-Phase Registration Flow
```csharp
public async Task<InitiateRegistrationResponse> InitiateRegistrationAsync(
    InitiateRegistrationRequest request,
    string ipAddress)
{
    var normalizedEmail = request.Email.Trim().ToLowerInvariant();

    // 1. Rate limit check (IP-based)
    var ipRateLimit = await _rateLimitService.CheckAndIncrementAsync(
        $"register:ip:{ipAddress}",
        _rateLimitConfig.MaxRegistrationsPerIpPerHour,
        TimeSpan.FromHours(1));

    if (!ipRateLimit.IsAllowed)
        return new InitiateRegistrationResponse(false, "Too many attempts. Try again later.", MaskEmail(normalizedEmail));

    // 2. Rate limit check (email-based daily limit)
    var emailRateLimit = await _rateLimitService.CheckAndIncrementAsync(
        $"register:email:{normalizedEmail}:daily",
        _rateLimitConfig.MaxCodesPerEmailPerDay,
        TimeSpan.FromHours(24));

    if (!emailRateLimit.IsAllowed)
        return new InitiateRegistrationResponse(false, "Too many attempts. Try again later.", MaskEmail(normalizedEmail));

    // 3. Check if email already registered (but don't reveal this!)
    var existingUser = await _userManager.FindByEmailAsync(normalizedEmail);

    // 4. Invalidate any existing pending codes for this email
    await InvalidatePendingCodesAsync(normalizedEmail, VerificationPurpose.Registration);

    // 5. Generate and store verification code
    var code = GenerateSecureCode();
    var verificationCode = new EmailVerificationCode
    {
        Email = normalizedEmail,
        UserId = null,  // No user yet
        Code = code,
        Purpose = VerificationPurpose.Registration.ToString(),
        ExpiresAt = DateTime.UtcNow.AddHours(1),
        IpAddress = ipAddress
    };

    // 6. Store pending registration data in cache (Redis) - expires in 1 hour
    var pendingData = new PendingRegistration
    {
        Email = normalizedEmail,
        PasswordHash = _passwordHasher.HashPassword(null!, request.Password),
        FirstName = request.FirstName,
        LastName = request.LastName,
        HomeTownId = request.HomeTownId,
        CreatedAt = DateTime.UtcNow
    };
    await _cache.SetAsync($"pending:registration:{normalizedEmail}", pendingData, TimeSpan.FromHours(1));

    // 7. Send email (different content if user exists vs new)
    if (existingUser != null)
    {
        // User exists - send "someone tried to register with your email" notification
        await _emailService.SendExistingAccountNotificationAsync(normalizedEmail);
    }
    else
    {
        // New user - send verification code
        _context.EmailVerificationCodes.Add(verificationCode);
        await _context.SaveChangesAsync();
        await _emailService.SendVerificationCodeAsync(normalizedEmail, code, request.FirstName);
    }

    // 8. ALWAYS return same response (prevents enumeration)
    return new InitiateRegistrationResponse(
        true,
        "If this email is not already registered, you will receive a verification code shortly.",
        MaskEmail(normalizedEmail));
}

public async Task<CompleteRegistrationResponse> CompleteRegistrationAsync(
    CompleteRegistrationRequest request,
    string ipAddress)
{
    var normalizedEmail = request.Email.Trim().ToLowerInvariant();

    // Use transaction for atomicity
    using var transaction = await _context.Database.BeginTransactionAsync();

    try
    {
        // 1. Find and validate verification code with optimistic locking
        var verificationCode = await _context.EmailVerificationCodes
            .Where(c => c.Email == normalizedEmail
                     && c.Purpose == VerificationPurpose.Registration.ToString()
                     && !c.IsUsed
                     && c.ExpiresAt > DateTime.UtcNow)
            .OrderByDescending(c => c.CreatedAt)
            .FirstOrDefaultAsync();

        if (verificationCode == null)
            return new CompleteRegistrationResponse(false, "Invalid or expired code.", null);

        // 2. Check attempt count
        if (verificationCode.AttemptCount >= _rateLimitConfig.MaxVerificationAttemptsPerCode)
            return new CompleteRegistrationResponse(false, "Too many failed attempts. Request a new code.", null);

        // 3. Verify code
        if (verificationCode.Code != request.Code)
        {
            verificationCode.AttemptCount++;
            verificationCode.RowVersion++;
            await _context.SaveChangesAsync();

            var remaining = _rateLimitConfig.MaxVerificationAttemptsPerCode - verificationCode.AttemptCount;
            return new CompleteRegistrationResponse(false, $"Invalid code. {remaining} attempts remaining.", null);
        }

        // 4. Mark code as used (optimistic concurrency via RowVersion)
        verificationCode.IsUsed = true;
        verificationCode.UsedAt = DateTime.UtcNow;
        verificationCode.RowVersion++;

        // 5. Check if user already exists (race condition protection)
        var existingUser = await _userManager.FindByEmailAsync(normalizedEmail);
        if (existingUser != null)
        {
            await transaction.RollbackAsync();
            return new CompleteRegistrationResponse(false, "Email already registered.", null);
        }

        // 6. Create user
        var user = new ApplicationUser
        {
            UserName = normalizedEmail,
            Email = normalizedEmail,
            NormalizedEmail = normalizedEmail.ToUpperInvariant(),
            FirstName = request.FirstName,
            LastName = request.LastName,
            HomeTownId = request.HomeTownId,
            EmailConfirmed = true,  // Already verified!
            CreatedAt = DateTime.UtcNow,
            LastLoginAt = DateTime.UtcNow
        };

        var result = await _userManager.CreateAsync(user, request.Password);
        if (!result.Succeeded)
        {
            await transaction.RollbackAsync();
            var errors = string.Join(", ", result.Errors.Select(e => e.Description));
            return new CompleteRegistrationResponse(false, $"Registration failed: {errors}", null);
        }

        // 7. Generate tokens
        var tokens = await GenerateTokensAsync(user);

        // 8. Commit transaction
        await _context.SaveChangesAsync();
        await transaction.CommitAsync();

        // 9. Clear rate limits for this email
        await _rateLimitService.ResetAsync($"register:email:{normalizedEmail}:daily");

        return new CompleteRegistrationResponse(true, "Registration successful!", tokens);
    }
    catch (DbUpdateConcurrencyException)
    {
        await transaction.RollbackAsync();
        return new CompleteRegistrationResponse(false, "Code already used. Please request a new one.", null);
    }
}
```

#### Secure Code Generation
```csharp
private string GenerateSecureCode()
{
    using var rng = RandomNumberGenerator.Create();
    var bytes = new byte[4];
    rng.GetBytes(bytes);
    var number = BitConverter.ToUInt32(bytes, 0) % 1000000;
    return number.ToString("D6");  // Pad with leading zeros
}
```

#### Login Update
```csharp
public async Task<TokenResponse> LoginAsync(LoginRequest request)
{
    var normalizedEmail = request.Email.Trim().ToLowerInvariant();
    var user = await _userManager.FindByEmailAsync(normalizedEmail);

    if (user == null)
        throw new UnauthorizedAccessException("Invalid email or password");

    // Check email confirmation
    if (!user.EmailConfirmed)
        throw new EmailNotVerifiedException("Please verify your email to continue", normalizedEmail);

    // ... rest of login logic
}
```

**Files to modify:**
- `backend/FamilyTreeApi/Services/IAuthService.cs`
- `backend/FamilyTreeApi/Services/AuthService.cs`

---

## Phase 6: Backend - Controller Updates

### 6.1 Update `AuthController.cs`

```csharp
// ============================================================================
// Two-Phase Registration Endpoints
// ============================================================================

/// <summary>
/// Phase 1: Initiate registration - send verification code
/// </summary>
[HttpPost("register/initiate")]
[ProducesResponseType(typeof(InitiateRegistrationResponse), 200)]
[ProducesResponseType(429)]  // Rate limited
public async Task<ActionResult<InitiateRegistrationResponse>> InitiateRegistration(
    [FromBody] InitiateRegistrationRequest request)
{
    var ipAddress = GetClientIpAddress();
    var response = await _authService.InitiateRegistrationAsync(request, ipAddress);
    return Ok(response);
}

/// <summary>
/// Phase 2: Complete registration - verify code and create account
/// </summary>
[HttpPost("register/complete")]
[ProducesResponseType(typeof(CompleteRegistrationResponse), 200)]
[ProducesResponseType(400)]
[ProducesResponseType(429)]
public async Task<ActionResult<CompleteRegistrationResponse>> CompleteRegistration(
    [FromBody] CompleteRegistrationRequest request)
{
    var ipAddress = GetClientIpAddress();
    var response = await _authService.CompleteRegistrationAsync(request, ipAddress);

    if (!response.Success)
        return BadRequest(response);

    return Ok(response);
}

// ============================================================================
// Verification & Password Reset Endpoints
// ============================================================================

[HttpPost("resend-code")]
[ProducesResponseType(typeof(ResendCodeResponse), 200)]
[ProducesResponseType(429)]
public async Task<ActionResult<ResendCodeResponse>> ResendCode([FromBody] ResendCodeRequest request)
{
    var ipAddress = GetClientIpAddress();
    var response = await _authService.ResendVerificationCodeAsync(request.Email, ipAddress);

    if (!response.Success && response.RetryAfterSeconds.HasValue)
    {
        Response.Headers.Add("Retry-After", response.RetryAfterSeconds.Value.ToString());
        return StatusCode(429, response);
    }

    return Ok(response);
}

[HttpPost("forgot-password")]
[ProducesResponseType(typeof(ForgotPasswordResponse), 200)]
public async Task<ActionResult<ForgotPasswordResponse>> ForgotPassword(
    [FromBody] ForgotPasswordRequest request)
{
    var ipAddress = GetClientIpAddress();

    // Add artificial delay to prevent timing attacks (200-500ms random)
    await Task.Delay(Random.Shared.Next(200, 500));

    var response = await _authService.ForgotPasswordAsync(request.Email, ipAddress);
    return Ok(response);  // Always 200 to prevent enumeration
}

[HttpPost("reset-password")]
[ProducesResponseType(typeof(ResetPasswordResponse), 200)]
[ProducesResponseType(400)]
public async Task<ActionResult<ResetPasswordResponse>> ResetPassword(
    [FromBody] ResetPasswordRequest request)
{
    var ipAddress = GetClientIpAddress();
    var response = await _authService.ResetPasswordAsync(request, ipAddress);

    if (!response.Success)
        return BadRequest(response);

    return Ok(response);
}

/// <summary>
/// Get towns for registration dropdown (public endpoint)
/// </summary>
[HttpGet("towns")]
[AllowAnonymous]
[ProducesResponseType(typeof(List<TownInfoDto>), 200)]
public async Task<ActionResult<List<TownInfoDto>>> GetTownsForRegistration()
{
    var towns = await _authService.GetAvailableTownsAsync();
    return Ok(towns.Towns);
}

// ============================================================================
// Helper Methods
// ============================================================================

private string GetClientIpAddress()
{
    // Check X-Forwarded-For header first (for proxies/load balancers)
    var forwardedFor = Request.Headers["X-Forwarded-For"].FirstOrDefault();
    if (!string.IsNullOrEmpty(forwardedFor))
    {
        var ip = forwardedFor.Split(',').FirstOrDefault()?.Trim();
        if (!string.IsNullOrEmpty(ip))
            return ip;
    }

    return HttpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown";
}
```

**Files to modify:**
- `backend/FamilyTreeApi/Controllers/AuthController.cs`

---

## Phase 7: Backend - Background Services

### 7.1 Expired Code Cleanup Service
```csharp
public class ExpiredCodeCleanupService : BackgroundService
{
    private readonly IServiceProvider _services;
    private readonly ILogger<ExpiredCodeCleanupService> _logger;

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                using var scope = _services.CreateScope();
                var context = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();

                // Delete codes expired more than 24 hours ago
                var cutoff = DateTime.UtcNow.AddHours(-24);
                var deleted = await context.EmailVerificationCodes
                    .Where(c => c.ExpiresAt < cutoff)
                    .ExecuteDeleteAsync(stoppingToken);

                if (deleted > 0)
                    _logger.LogInformation("Cleaned up {Count} expired verification codes", deleted);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error cleaning up expired codes");
            }

            // Run every hour
            await Task.Delay(TimeSpan.FromHours(1), stoppingToken);
        }
    }
}
```

**Files to create:**
- `backend/FamilyTreeApi/Services/ExpiredCodeCleanupService.cs` - **NEW FILE**

---

## Phase 8: Frontend - Models & Services

### 8.1 Update `auth.models.ts`
```typescript
// ============================================================================
// Registration (Two-Phase)
// ============================================================================

export interface InitiateRegistrationRequest {
    email: string;
    password: string;
    firstName: string;
    lastName: string;
    homeTownId?: string;
}

export interface InitiateRegistrationResponse {
    success: boolean;
    message: string;
    email: string;  // Masked email
}

export interface CompleteRegistrationRequest {
    email: string;
    code: string;
    password: string;
    firstName: string;
    lastName: string;
    homeTownId?: string;
}

export interface CompleteRegistrationResponse {
    success: boolean;
    message: string;
    tokens?: AuthResponse;
}

// ============================================================================
// Verification & Password Reset
// ============================================================================

export interface ResendCodeRequest {
    email: string;
    purpose: 'Registration' | 'PasswordReset';
}

export interface ResendCodeResponse {
    success: boolean;
    message: string;
    retryAfterSeconds?: number;
}

export interface ForgotPasswordRequest {
    email: string;
}

export interface ForgotPasswordResponse {
    success: boolean;
    message: string;
}

export interface ResetPasswordRequest {
    email: string;
    code: string;
    newPassword: string;
}

export interface ResetPasswordResponse {
    success: boolean;
    message: string;
}

// ============================================================================
// Updated User Interface
// ============================================================================

export interface User {
    id: number;
    email: string;
    firstName: string | null;
    lastName: string | null;
    emailConfirmed: boolean;
    orgId: string | null;
    orgName: string | null;
    role: OrgRole;
    systemRole: SystemRole;
    preferredLanguage: string;
    isFirstLogin: boolean;
    selectedTownId: string | null;
    selectedTownName: string | null;
    homeTownId: string | null;      // NEW
    homeTownName: string | null;    // NEW
}
```

### 8.2 Update `auth.service.ts`
```typescript
// Store pending registration data for two-phase flow
private pendingRegistration: InitiateRegistrationRequest | null = null;

// ============================================================================
// Two-Phase Registration
// ============================================================================

initiateRegistration(request: InitiateRegistrationRequest): Observable<InitiateRegistrationResponse> {
    // Store for phase 2
    this.pendingRegistration = request;
    sessionStorage.setItem('pendingRegistration', JSON.stringify(request));

    return this.http.post<InitiateRegistrationResponse>(
        `${this.apiUrl}/register/initiate`,
        request
    );
}

completeRegistration(code: string): Observable<CompleteRegistrationResponse> {
    const pending = this.getPendingRegistration();
    if (!pending) {
        return throwError(() => new Error('No pending registration found'));
    }

    const request: CompleteRegistrationRequest = {
        ...pending,
        code
    };

    return this.http.post<CompleteRegistrationResponse>(
        `${this.apiUrl}/register/complete`,
        request
    ).pipe(
        tap(response => {
            if (response.success && response.tokens) {
                this.handleAuthResponse(response.tokens);
                this.clearPendingRegistration();
            }
        })
    );
}

private getPendingRegistration(): InitiateRegistrationRequest | null {
    if (this.pendingRegistration) return this.pendingRegistration;

    const stored = sessionStorage.getItem('pendingRegistration');
    if (stored) {
        this.pendingRegistration = JSON.parse(stored);
        return this.pendingRegistration;
    }
    return null;
}

private clearPendingRegistration(): void {
    this.pendingRegistration = null;
    sessionStorage.removeItem('pendingRegistration');
}

// ============================================================================
// Verification & Password Reset
// ============================================================================

resendCode(email: string, purpose: 'Registration' | 'PasswordReset'): Observable<ResendCodeResponse> {
    return this.http.post<ResendCodeResponse>(`${this.apiUrl}/resend-code`, { email, purpose });
}

forgotPassword(email: string): Observable<ForgotPasswordResponse> {
    return this.http.post<ForgotPasswordResponse>(`${this.apiUrl}/forgot-password`, { email });
}

resetPassword(request: ResetPasswordRequest): Observable<ResetPasswordResponse> {
    return this.http.post<ResetPasswordResponse>(`${this.apiUrl}/reset-password`, request);
}

getTownsForRegistration(): Observable<TownInfo[]> {
    return this.http.get<TownInfo[]>(`${this.apiUrl}/towns`);
}
```

**Files to modify:**
- `frontend/src/app/core/models/auth.models.ts`
- `frontend/src/app/core/services/auth.service.ts`

---

## Phase 9: Frontend - Registration Component

### 9.1 Update `register.component.ts`
```typescript
@Component({
    selector: 'app-register',
    standalone: true,
    imports: [
        CommonModule,
        RouterModule,
        ReactiveFormsModule,
        MatCardModule,
        MatFormFieldModule,
        MatInputModule,
        MatButtonModule,
        MatSelectModule,
        MatProgressSpinnerModule,
        MatSnackBarModule,
        TranslateModule
    ],
    templateUrl: './register.component.html',
    styleUrls: ['./register.component.scss']
})
export class RegisterComponent implements OnInit {
    registerForm: FormGroup;
    loading = false;
    towns: TownInfo[] = [];
    townsLoading = true;

    constructor(
        private fb: FormBuilder,
        private authService: AuthService,
        private router: Router,
        private snackBar: MatSnackBar,
        private i18n: I18nService
    ) {
        this.registerForm = this.fb.group({
            firstName: ['', Validators.required],
            lastName: ['', Validators.required],
            email: ['', [Validators.required, Validators.email]],
            password: ['', [
                Validators.required,
                Validators.minLength(8),
                Validators.pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).+$/)  // Match backend requirements
            ]],
            homeTownId: [null]  // Optional
        });
    }

    ngOnInit(): void {
        this.loadTowns();
    }

    private loadTowns(): void {
        this.authService.getTownsForRegistration().subscribe({
            next: (towns) => {
                this.towns = towns;
                this.townsLoading = false;
            },
            error: () => {
                this.townsLoading = false;
                // Don't block registration if towns fail to load
            }
        });
    }

    onSubmit(): void {
        if (this.registerForm.invalid) return;

        this.loading = true;
        const request: InitiateRegistrationRequest = this.registerForm.value;

        this.authService.initiateRegistration(request).subscribe({
            next: (response) => {
                this.loading = false;
                // Navigate to verification page with email
                this.router.navigate(['/verify-email'], {
                    state: { email: request.email }
                });
            },
            error: (error) => {
                this.loading = false;
                this.snackBar.open(
                    error.error?.message || this.i18n.t('auth.registerFailed'),
                    this.i18n.t('common.close'),
                    { duration: 5000, panelClass: ['error-snackbar'] }
                );
            }
        });
    }
}
```

### 9.2 Update `register.component.html`
```html
<div class="nubian-auth">
    <div class="nubian-auth__pattern"></div>

    <div class="nubian-auth__card">
        <div class="nubian-auth__header">
            <div class="nubian-auth__logo">
                <i class="fa-solid fa-user-plus" aria-hidden="true"></i>
            </div>
            <h1>{{ 'app.title' | translate }} {{ 'app.platform' | translate }}</h1>
            <p>{{ 'auth.createAccount' | translate }}</p>
        </div>

        <div class="nubian-auth__content">
            <form [formGroup]="registerForm" (ngSubmit)="onSubmit()" class="nubian-auth__form">
                <div class="form-row">
                    <mat-form-field appearance="outline">
                        <mat-label>{{ 'auth.firstName' | translate }}</mat-label>
                        <input matInput formControlName="firstName" autocomplete="given-name">
                        <i class="fa-solid fa-user" matPrefix aria-hidden="true"></i>
                        <mat-error *ngIf="registerForm.get('firstName')?.hasError('required')">
                            {{ 'validation.firstNameRequired' | translate }}
                        </mat-error>
                    </mat-form-field>

                    <mat-form-field appearance="outline">
                        <mat-label>{{ 'auth.lastName' | translate }}</mat-label>
                        <input matInput formControlName="lastName" autocomplete="family-name">
                        <i class="fa-solid fa-user" matPrefix aria-hidden="true"></i>
                        <mat-error *ngIf="registerForm.get('lastName')?.hasError('required')">
                            {{ 'validation.lastNameRequired' | translate }}
                        </mat-error>
                    </mat-form-field>
                </div>

                <mat-form-field appearance="outline">
                    <mat-label>{{ 'auth.email' | translate }}</mat-label>
                    <input matInput type="email" formControlName="email" autocomplete="email">
                    <i class="fa-solid fa-envelope" matPrefix aria-hidden="true"></i>
                    <mat-error *ngIf="registerForm.get('email')?.hasError('required')">
                        {{ 'validation.emailRequired' | translate }}
                    </mat-error>
                    <mat-error *ngIf="registerForm.get('email')?.hasError('email')">
                        {{ 'validation.invalidEmail' | translate }}
                    </mat-error>
                </mat-form-field>

                <mat-form-field appearance="outline">
                    <mat-label>{{ 'auth.password' | translate }}</mat-label>
                    <input matInput type="password" formControlName="password" autocomplete="new-password">
                    <i class="fa-solid fa-lock" matPrefix aria-hidden="true"></i>
                    <mat-error *ngIf="registerForm.get('password')?.hasError('required')">
                        {{ 'validation.passwordRequired' | translate }}
                    </mat-error>
                    <mat-error *ngIf="registerForm.get('password')?.hasError('minlength')">
                        {{ 'validation.passwordMinLength' | translate }}
                    </mat-error>
                    <mat-error *ngIf="registerForm.get('password')?.hasError('pattern')">
                        {{ 'validation.passwordPattern' | translate }}
                    </mat-error>
                    <mat-hint>{{ 'auth.passwordHint' | translate }}</mat-hint>
                </mat-form-field>

                <!-- HomeTown Selection (Optional) -->
                <mat-form-field appearance="outline">
                    <mat-label>{{ 'auth.homeTown' | translate }}</mat-label>
                    <mat-select formControlName="homeTownId">
                        <mat-option [value]="null">{{ 'auth.preferNotToSay' | translate }}</mat-option>
                        <mat-option *ngFor="let town of towns" [value]="town.id">
                            {{ town.name }}
                        </mat-option>
                    </mat-select>
                    <i class="fa-solid fa-location-dot" matPrefix aria-hidden="true"></i>
                    <mat-hint>{{ 'auth.homeTownHint' | translate }}</mat-hint>
                </mat-form-field>

                <button
                    mat-raised-button
                    type="submit"
                    class="nubian-auth__submit"
                    [disabled]="registerForm.invalid || loading">
                    @if (loading) {
                        <mat-spinner diameter="20"></mat-spinner>
                    } @else {
                        <i class="fa-solid fa-user-plus" aria-hidden="true"></i>
                        <span>{{ 'auth.createAccountButton' | translate }}</span>
                    }
                </button>
            </form>

            <div class="nubian-auth__footer">
                <p>{{ 'auth.alreadyHaveAccount' | translate }} <a routerLink="/login">{{ 'auth.loginHere' | translate }}</a></p>
            </div>
        </div>
    </div>
</div>
```

**Files to modify:**
- `frontend/src/app/features/auth/register.component.ts`
- `frontend/src/app/features/auth/register.component.html`

---

## Phase 10: Frontend - New Components

### 10.1 Create `verify-email.component.ts`
```typescript
@Component({
    selector: 'app-verify-email',
    standalone: true,
    imports: [
        CommonModule,
        RouterModule,
        ReactiveFormsModule,
        MatCardModule,
        MatFormFieldModule,
        MatInputModule,
        MatButtonModule,
        MatProgressSpinnerModule,
        MatSnackBarModule,
        TranslateModule
    ],
    templateUrl: './verify-email.component.html',
    styleUrls: ['./verify-email.component.scss']
})
export class VerifyEmailComponent implements OnInit, OnDestroy {
    @ViewChildren('codeInput') codeInputs!: QueryList<ElementRef>;

    codeForm: FormGroup;
    email: string = '';
    loading = false;
    resendLoading = false;
    resendCountdown = 0;
    private countdownInterval?: number;

    constructor(
        private fb: FormBuilder,
        private authService: AuthService,
        private router: Router,
        private route: ActivatedRoute,
        private snackBar: MatSnackBar,
        private i18n: I18nService
    ) {
        this.codeForm = this.fb.group({
            digit1: ['', [Validators.required, Validators.pattern(/^\d$/)]],
            digit2: ['', [Validators.required, Validators.pattern(/^\d$/)]],
            digit3: ['', [Validators.required, Validators.pattern(/^\d$/)]],
            digit4: ['', [Validators.required, Validators.pattern(/^\d$/)]],
            digit5: ['', [Validators.required, Validators.pattern(/^\d$/)]],
            digit6: ['', [Validators.required, Validators.pattern(/^\d$/)]]
        });
    }

    ngOnInit(): void {
        // Get email from route state or sessionStorage
        const state = history.state;
        this.email = state?.email || sessionStorage.getItem('verifyEmail') || '';

        if (!this.email) {
            // No email context, redirect to register
            this.router.navigate(['/register']);
            return;
        }

        // Store for page refresh
        sessionStorage.setItem('verifyEmail', this.email);
    }

    ngOnDestroy(): void {
        if (this.countdownInterval) {
            clearInterval(this.countdownInterval);
        }
        sessionStorage.removeItem('verifyEmail');
    }

    onDigitInput(event: Event, index: number): void {
        const input = event.target as HTMLInputElement;
        const value = input.value;

        if (value && index < 5) {
            // Auto-focus next input
            const inputs = this.codeInputs.toArray();
            inputs[index + 1]?.nativeElement.focus();
        }
    }

    onPaste(event: ClipboardEvent): void {
        event.preventDefault();
        const pastedData = event.clipboardData?.getData('text') || '';
        const digits = pastedData.replace(/\D/g, '').slice(0, 6);

        if (digits.length === 6) {
            const controls = ['digit1', 'digit2', 'digit3', 'digit4', 'digit5', 'digit6'];
            controls.forEach((control, i) => {
                this.codeForm.get(control)?.setValue(digits[i]);
            });
        }
    }

    onKeydown(event: KeyboardEvent, index: number): void {
        if (event.key === 'Backspace' && index > 0) {
            const input = event.target as HTMLInputElement;
            if (!input.value) {
                const inputs = this.codeInputs.toArray();
                inputs[index - 1]?.nativeElement.focus();
            }
        }
    }

    getCode(): string {
        return Object.values(this.codeForm.value).join('');
    }

    onSubmit(): void {
        if (this.codeForm.invalid) return;

        this.loading = true;
        this.authService.completeRegistration(this.getCode()).subscribe({
            next: (response) => {
                this.loading = false;
                if (response.success) {
                    this.snackBar.open(
                        this.i18n.t('auth.emailVerified'),
                        this.i18n.t('common.close'),
                        { duration: 3000 }
                    );
                    this.router.navigate(['/']);  // Goes to onboarding via guard
                } else {
                    this.snackBar.open(
                        response.message,
                        this.i18n.t('common.close'),
                        { duration: 5000, panelClass: ['error-snackbar'] }
                    );
                }
            },
            error: (error) => {
                this.loading = false;
                this.snackBar.open(
                    error.error?.message || this.i18n.t('auth.invalidCode'),
                    this.i18n.t('common.close'),
                    { duration: 5000, panelClass: ['error-snackbar'] }
                );
            }
        });
    }

    resendCode(): void {
        if (this.resendCountdown > 0) return;

        this.resendLoading = true;
        this.authService.resendCode(this.email, 'Registration').subscribe({
            next: (response) => {
                this.resendLoading = false;
                if (response.success) {
                    this.snackBar.open(
                        this.i18n.t('auth.codeSent'),
                        this.i18n.t('common.close'),
                        { duration: 3000 }
                    );
                    this.startCountdown(60);
                } else {
                    this.startCountdown(response.retryAfterSeconds || 60);
                }
            },
            error: (error) => {
                this.resendLoading = false;
                if (error.status === 429) {
                    const retryAfter = parseInt(error.headers.get('Retry-After') || '60', 10);
                    this.startCountdown(retryAfter);
                }
            }
        });
    }

    private startCountdown(seconds: number): void {
        this.resendCountdown = seconds;
        this.countdownInterval = window.setInterval(() => {
            this.resendCountdown--;
            if (this.resendCountdown <= 0 && this.countdownInterval) {
                clearInterval(this.countdownInterval);
            }
        }, 1000);
    }
}
```

### 10.2 Create `forgot-password.component.ts` and `reset-password.component.ts`
(Similar patterns to verify-email, with appropriate form fields and API calls)

**New files:**
- `frontend/src/app/features/auth/verify-email.component.ts`
- `frontend/src/app/features/auth/verify-email.component.html`
- `frontend/src/app/features/auth/verify-email.component.scss`
- `frontend/src/app/features/auth/forgot-password.component.ts`
- `frontend/src/app/features/auth/forgot-password.component.html`
- `frontend/src/app/features/auth/forgot-password.component.scss`
- `frontend/src/app/features/auth/reset-password.component.ts`
- `frontend/src/app/features/auth/reset-password.component.html`
- `frontend/src/app/features/auth/reset-password.component.scss`

---

## Phase 11: Frontend - Routes & Login Updates

### 11.1 Update `app.routes.ts`
```typescript
export const routes: Routes = [
    // ... existing routes

    // Auth routes (public)
    {
        path: 'verify-email',
        loadComponent: () => import('./features/auth/verify-email.component')
            .then(m => m.VerifyEmailComponent)
    },
    {
        path: 'forgot-password',
        loadComponent: () => import('./features/auth/forgot-password.component')
            .then(m => m.ForgotPasswordComponent)
    },
    {
        path: 'reset-password',
        loadComponent: () => import('./features/auth/reset-password.component')
            .then(m => m.ResetPasswordComponent)
    },
];
```

### 11.2 Update `login.component.html`
```html
<!-- Add after password field -->
<div class="nubian-auth__forgot">
    <a routerLink="/forgot-password">{{ 'auth.forgotPassword' | translate }}</a>
</div>
```

### 11.3 Update `login.component.ts`
```typescript
// Handle EMAIL_NOT_VERIFIED error
onSubmit(): void {
    // ... existing code

    this.authService.login(this.loginForm.value).subscribe({
        next: () => {
            this.router.navigate(['/']);
        },
        error: (error) => {
            this.loading = false;

            // Check for email not verified error
            if (error.error?.code === 'EMAIL_NOT_VERIFIED') {
                this.router.navigate(['/verify-email'], {
                    state: { email: this.loginForm.get('email')?.value }
                });
                return;
            }

            this.snackBar.open(
                error.error?.message || this.i18n.t('auth.loginFailed'),
                this.i18n.t('common.close'),
                { duration: 3000, panelClass: ['error-snackbar'] }
            );
        }
    });
}
```

**Files to modify:**
- `frontend/src/app/app.routes.ts`
- `frontend/src/app/features/auth/login.component.ts`
- `frontend/src/app/features/auth/login.component.html`

---

## Phase 12: Translations (i18n)

### Add to all language files:
```json
{
    "auth": {
        "homeTown": "Where are you from?",
        "homeTownHint": "Optional - helps connect you with your community",
        "preferNotToSay": "Prefer not to say",
        "passwordHint": "Min 8 characters with uppercase, lowercase, and number",
        "verifyEmail": "Verify Your Email",
        "verificationCodeSent": "We've sent a 6-digit code to",
        "enterCode": "Enter verification code",
        "verifyButton": "Verify",
        "resendCode": "Resend Code",
        "resendIn": "Resend in {{seconds}}s",
        "codeExpiry": "Code expires in 1 hour",
        "forgotPassword": "Forgot Password?",
        "forgotPasswordTitle": "Reset Your Password",
        "forgotPasswordInstructions": "Enter your email and we'll send you a code to reset your password",
        "sendResetCode": "Send Reset Code",
        "resetPassword": "Reset Password",
        "newPassword": "New Password",
        "confirmPassword": "Confirm Password",
        "resetPasswordButton": "Reset Password",
        "passwordResetSuccess": "Password reset successfully! Please login with your new password.",
        "emailVerified": "Email verified successfully!",
        "invalidCode": "Invalid or expired code. Please try again.",
        "codeSent": "Verification code sent to your email",
        "pleaseVerifyEmail": "Please verify your email to continue",
        "checkYourEmail": "Check your email",
        "tooManyAttempts": "Too many attempts. Please try again later."
    },
    "validation": {
        "passwordsNotMatch": "Passwords do not match",
        "codeRequired": "Verification code is required",
        "codeLength": "Code must be 6 digits",
        "passwordMinLength": "Password must be at least 8 characters",
        "passwordPattern": "Password must contain uppercase, lowercase, and a number"
    }
}
```

**Files to modify:**
- `frontend/src/assets/i18n/en.json`
- `frontend/src/assets/i18n/ar.json`
- `frontend/src/assets/i18n/nob.json`

---

## Security Summary (Audit Fixes)

| Issue | Fix |
|-------|-----|
| 🔴 Brute force on 6-digit code | IP + email rate limiting via Redis; max 5 attempts per code; account lockout after 15 failed attempts |
| 🔴 User enumeration via registration | Two-phase registration; always return same response; send different emails |
| 🔴 Missing transaction in registration | Full transaction wrapping with rollback on failure |
| 🔴 User created before verification | Two-phase: user created ONLY after code verification |
| 🔴 SMTP credentials in config | Environment variables placeholder; document secrets management |
| 🟠 Race condition in verification | Optimistic concurrency with RowVersion |
| 🟠 Unlimited code requests | Max 10 codes per email per 24 hours |
| 🟠 Timing attack on forgot password | Artificial random delay (200-500ms) |
| 🟠 Frontend state loss on refresh | sessionStorage backup; graceful redirect |
| 🟠 No cleanup of expired codes | Background service runs hourly |
| 🟠 Email service failure handling | Return result with error; retry logic; logging |
| 🟡 Password validation mismatch | Frontend now matches backend (8 chars, pattern) |

---

## Files Summary

### New Files (18)
| File | Description |
|------|-------------|
| `backend/FamilyTreeApi/Models/EmailVerificationCode.cs` | Verification code entity with concurrency |
| `backend/FamilyTreeApi/Models/RateLimitEntry.cs` | DB fallback for rate limiting |
| `backend/FamilyTreeApi/Models/Configuration/EmailConfiguration.cs` | SMTP config model |
| `backend/FamilyTreeApi/Models/Configuration/RateLimitConfiguration.cs` | Rate limit settings |
| `backend/FamilyTreeApi/Services/IEmailService.cs` | Email service interface |
| `backend/FamilyTreeApi/Services/EmailService.cs` | Email service with retry |
| `backend/FamilyTreeApi/Services/IRateLimitService.cs` | Rate limit interface |
| `backend/FamilyTreeApi/Services/RateLimitService.cs` | Redis-based rate limiting |
| `backend/FamilyTreeApi/Services/ExpiredCodeCleanupService.cs` | Background cleanup |
| `frontend/src/app/features/auth/verify-email.component.ts` | Verify email component |
| `frontend/src/app/features/auth/verify-email.component.html` | Verify email template |
| `frontend/src/app/features/auth/verify-email.component.scss` | Verify email styles |
| `frontend/src/app/features/auth/forgot-password.component.ts` | Forgot password component |
| `frontend/src/app/features/auth/forgot-password.component.html` | Forgot password template |
| `frontend/src/app/features/auth/forgot-password.component.scss` | Forgot password styles |
| `frontend/src/app/features/auth/reset-password.component.ts` | Reset password component |
| `frontend/src/app/features/auth/reset-password.component.html` | Reset password template |
| `frontend/src/app/features/auth/reset-password.component.scss` | Reset password styles |

### Modified Files (17)
| File | Changes |
|------|---------|
| `backend/FamilyTreeApi/Models/ApplicationUser.cs` | Add HomeTownId |
| `backend/FamilyTreeApi/Data/ApplicationDbContext.cs` | Add DbSets, configure entities |
| `backend/FamilyTreeApi/DTOs/AuthDTOs.cs` | Two-phase registration DTOs |
| `backend/FamilyTreeApi/Services/IAuthService.cs` | New method signatures |
| `backend/FamilyTreeApi/Services/AuthService.cs` | Two-phase implementation |
| `backend/FamilyTreeApi/Controllers/AuthController.cs` | New endpoints with IP tracking |
| `backend/FamilyTreeApi/Program.cs` | Register all new services |
| `backend/FamilyTreeApi/appsettings.json` | Email + rate limit settings |
| `frontend/src/app/core/models/auth.models.ts` | New interfaces |
| `frontend/src/app/core/services/auth.service.ts` | Two-phase methods |
| `frontend/src/app/features/auth/register.component.ts` | HomeTown + two-phase |
| `frontend/src/app/features/auth/register.component.html` | HomeTown field |
| `frontend/src/app/features/auth/login.component.ts` | Handle unverified |
| `frontend/src/app/features/auth/login.component.html` | Forgot password link |
| `frontend/src/app/app.routes.ts` | New routes |
| `frontend/src/assets/i18n/*.json` | Translation keys (3 files) |
| `DB/migration_email_verification.sql` | Database migration |

---

## Estimated Effort (Revised)

| Phase | Estimated Time |
|-------|----------------|
| Database & Models | 2 hours |
| Rate Limiting Service (Redis) | 3 hours |
| Email Service with Retry | 2 hours |
| Auth Service (Two-Phase) | 5 hours |
| Controller Updates | 2 hours |
| Background Cleanup Service | 1 hour |
| Frontend Models & Service | 2 hours |
| Registration Component | 2 hours |
| Verify Email Component | 3 hours |
| Forgot/Reset Password | 3 hours |
| Routes & Login Updates | 1 hour |
| Translations | 1 hour |
| Testing | 4 hours |
| **Total** | **~31 hours** |
