




{
    "ConnectionStrings": {
    "default": "User ID=xxx;Password=yyyyy;Host=yyyyyy;Port=5432;Database=FamilyTree;Pooling=true; Minimum Pool Size=5; Maximum Pool Size=50;Keepalive=30; Timeout=60",
    "redis": "redis2:6379,abortConnect=false,connectTimeout=15000,syncTimeout=15000,connectRetry=5,defaultDatabase=0"
  },
 
  "Serilog": {
    "Using": [
      "Serilog.Enrichers.ClientInfo",
      "Serilog.Sinks.Console",
      "Serilog.Sinks.File"
    ],
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning",
        "Microsoft.AspNetCore.SignalR": "Warning",
        "Microsoft.AspNetCore.Http.Connections": "Warning",
        "Services": "Information"
      }
    },
    "Enrich": [
      "FromLogContext",
      "WithExceptionDetails",
      "SqlExceptionDestructor",
      "DbUpdateExceptionDestructor",
      "WithClientIp",
      "WithClientAgent"
    ],
    "WriteTo": [
      {
        "Name": "Console",
        "Args": {
          "outputTemplate": "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u6}] {Message:lj}{NewLine}{Exception}"
        }
      },
      {
        "Name": "File",
        "Args": {
          "path": "./Logs/log.txt",
          "formatter": "Serilog.Formatting.Json.JsonFormatter, Serilog",
          "rollingInterval": "Day",
          "outputTemplate": "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u6}] {Message:lj}{NewLine}{Exception}"
        }
      }
    ]
  },
  "redisInstance": "nobiin:",
  "Redis": {
    "Enabled": true,
    "InstanceName": "nobiin:",
    "ConnectionString": "redis2:6379,abortConnect=false,connectTimeout=15000,syncTimeout=15000",
    "ChannelPrefix": "nobiin-",
    "User": "",
    "Password": "",
    "RedisConnections": [ "redis2:6379" ]
  },
  "SignalRRedisOptions": {
    "clientName": "nobiin-signalr",
    "channelPrefix": "nobiin-signalr-",
    "connectionTimeOut": 15000,
    "user": "",
    "password": "",
    "redisConnections": [ "redis2:6379" ]
  },
  "Cors": "",
  "JwtSettings": {
    "validationParameters": {
      "ValidateIssuer": true,
      "ValidateAudience": true,
      "ValidateLifetime": true,
      "ValidateIssuerSigningKey": true,
      "ValidIssuer": "https://localhost:7155",
      "ValidAudience": "http://localhost:4200",
      "ClockSkew": 5,
      "LifeTimeInMinutes": 15
    },
    "tokenOptions": {
      "bearerTokenLifeTimeStr": "00:00:15:00",
      "refreshTokenLifeTimeStr": "30:00:00:00",
      "signerTokenLifetimeStr": "30:00:00:00",
      "refreshTokenEncryptionKey": "AAAAfh123456789abcdefghijklmno",
      "bearerTokenKeyStr": "Board@#$%*&_1234567890_1!_2@",
      "signerTokenKeyStr": "BoardMe%*&_1234567890_1!_2@"
    },
    "hubOptions": {
      "baseRoute": "/hubs",
      "tokenQuery": "access-token"
    }
  },
  "IdentityOptions": {
    "signInOptions": {
      "RequireConfirmedAccount": false,
      "RequireConfirmedEmail": false,
      "RequireConfirmedPhoneNumber": false
    },
    "userOptions": {
      "requireUniqueEmail": true
    },
    "lockoutOptions": {
      "AllowedForNewUsers": true,
      "MaxFailedAccessAttempts": 5,
      "DefaultLockoutTimeSpan": "00:30:00"
    },
    "passwordOptions": {
      "RequireDigit": true,
      "RequireLowercase": true,
      "RequireUppercase": true,
      "RequireNonAlphanumeric": true,
      "RequiredLength": 8,
      "RequiredUniqueChars": 1
    }
  },
  "Turnstile": {
    "Secret": "0x"
  },
  "TTS": {
    "Engine": "google",
    "Google": {
      "ApiKey": "AIz5tmc",
      "ProjectId": "nobiin-tts"
    }
  },
  "FFmpeg": {
    "ExecutablePath": "ffmpeg",
    "TempDirectory": "/tmp/ffmpeg-processing",
    "TimeoutSeconds": 60,
    "DefaultBitrate": "128k",
    "EnableCrossfade": true,
    "CrossfadeDuration": 0.1,
    "NormalizationTarget": -16.0
  },
  "StorageConfiguration": {
    "StorageType": "LocalStorage",
    "CompressionEnabled": true,
    "StorageCacheEnabled": true,

    "LocalStorage": {
      "BasePath": "/var/www/xxxx/"
    },
    "AWS": {
      "AccessKey": "",
      "SecretKey": "",
      "Region": "CACentral13434",
      "BucketName": "xxxxe",
      "BasePath": "x"
    },
    "Linode": {
      "AccessKey": "",
      "SecretKey": "",
      "S3Endpoint": "https://xxxxxx.com",
      "BucketName": "xxxx",
      "BasePath": "realestate"
    },
    "Nextcloud": {
      "BaseUrl": "https://nxxxxxxcom",
      "Username": "your_username",
      "Password": "your_password",
      "BasePath": "/path/to/storage"
    },
    "Cloudflare": {
      "AccountId": "your-cloudflare-account-id",
      "AccessKey": "your-r2-access-key-id",
      "SecretKey": "your-r2-secret-access-key",
      "BucketName": "xxxxxe",
      "BasePath": "xxxxxt"
    }
  }
}















using HealthChecks.UI.Client;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Authorization.Policy;
using Microsoft.AspNetCore.Diagnostics.HealthChecks;
using Microsoft.AspNetCore.Http.Features;
using Microsoft.AspNetCore.HttpOverrides;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
using Microsoft.Extensions.Caching.Distributed;
using Microsoft.Extensions.Options;
using Serilog;
using System.Text;
using NobiinDictionary.App;
using NobiinDictionary.App.Admin;
using NobiinDictionary.App.Hubs;
using NobiinDictionary.App.Infrastructure;
using NobiinDictionary.Core;
using NobiinDictionary.Core.Models;
using NobiinDictionary.JwtAuth;
using NobiinDictionary.JwtAuth.Services;
using VirtualUpon.Storage.Factories;
using NobiinDictionary.DAL;
using VirtualUpon.Storage.Utilities;
using NobiinDictionary.Core.Identity;
using static NobiinDictionary.App.Infrastructure.SwaggerAuthentication;
using WebDav;
using NobiinDictionary.Core.Services;
using NobiinDictionary.API.Extensions;
using NobiinDictionary.API.Services.Interfaces;
using NobiinDictionary.DAL.Repositories.Implementations;
using NobiinDictionary.DAL.Repositories.Interfaces;
using NobiinDictionary.API.Services.Implementations;
using Microsoft.AspNetCore.RateLimiting;
using NobiinDictionary.API.Middleware;
using System.Threading.RateLimiting;

// -------------------------------
// BUILDER
// -------------------------------
var builder = WebApplication.CreateBuilder(args);

// Kestrel: Unlimited body size (for Base64 audio)
builder.WebHost.ConfigureKestrel(opt => opt.Limits.MaxRequestBodySize = null);

// Serilog
builder.Host.UseSerilog((context, loggerConfiguration) =>
    loggerConfiguration.ReadFrom.Configuration(context.Configuration));

// Swagger / OpenAPI
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddOpenApiDocument(document =>
{
    document.Title = "Nobiin Dictionary API";
    document.Version = "v1";
});

// Form options (for large Base64)
builder.Services.Configure<FormOptions>(options =>
{
    options.ValueLengthLimit = int.MaxValue;
    options.MultipartBodyLengthLimit = int.MaxValue;
});

var services = builder.Services;
var configuration = builder.Configuration;

// -------------------------------
// CORE SERVICES
// -------------------------------
services
   .AddCore()
   .AddSignalR(configuration)
   .AddDataAccessLayer(configuration)
   .AddStackExchangeRedisCache(options =>
   {
       options.InstanceName = configuration["redisInstance"];
       options.Configuration = configuration.GetConnectionString("redis");
   })
   .AddEndpointsApiExplorer()
   .AddAdminModule()
   .AddSwaggerGen(AddSwaggerAuth());

// Health Checks
services.AddHealthChecks()
    .AddNpgSql(configuration.GetConnectionString("default")!)
    .AddRedis(configuration.GetConnectionString("redis")!);

// -------------------------------
// CORS (SECURE)
// -------------------------------
//var allowedOrigins = configuration["Cors"]?
//    .Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)
//    ?? new[]
//    {
//        "http://localhost",
//        "https://nobiinlanguage.com",
//        "https://www.nobiinlanguage.com",
//        "http://localhost:4200",
//        "https://localhost:4200",
//        "http://127.0.0.1:4200",
//        "http://nobiinlanguage.com"
//    };

//services.AddCors(options =>
//{
//    options.AddDefaultPolicy(policy =>
//    {
//        policy.WithOrigins(allowedOrigins)
//              .AllowAnyHeader()
//              .AllowAnyMethod();
//        //.AllowCredentials(); // add this if you need cookies/auth headers
//    });
//});

// -------------------------------
// CORS - SIMPLE DEBUG VERSION
// -------------------------------
services.AddCors(options =>
{
    options.AddDefaultPolicy(policy =>
    {
        // ⚠️ TEMPORARY: Allow everything for debugging
        policy.SetIsOriginAllowed(_ => true)
              .AllowAnyHeader()
              .AllowAnyMethod()
              .AllowCredentials();
    });
});

// -------------------------------
// AUTH & POLICIES
// -------------------------------
services.AddControllers();
services
    .AddJwtAuth(configuration)
    .AddAuthorizationBuilder()
    .AddPolicy(AuthorizationPolicies.NonRevokedToken,
        p => p.AddRequirements(new NonRevokedTokenRequirement()))
    .AddPolicy(AuthorizationPolicies.AdminOnly,
        p => p.AddRequirements(new AdminAccessRequirement()))
    .AddPolicy("AgentOrAdminAccessPolicy", policy =>
        policy.RequireAssertion(context =>
            context.User.HasClaim(c => c.Type == "AgentAccess") ||
            context.User.HasClaim(c => c.Type == "AdminAccess")));

services.AddSingleton<IAuthorizationMiddlewareResultHandler, ForbiddenAuthorizationMiddlewareResultHandler>();
services.AddHttpContextAccessor();

// -------------------------------
// STORAGE CONFIG
// -------------------------------
services.Configure<StorageConfiguration>(configuration.GetSection("StorageConfiguration"));
services.AddSingleton(resolver => resolver.GetRequiredService<IOptions<StorageConfiguration>>().Value);


// -------------------------------
// STORAGE SERVICE FACTORY
// -------------------------------
services.AddScoped<IStorageService>(provider =>
{
    var config = provider.GetRequiredService<IConfiguration>()
        .GetSection("StorageConfiguration").Get<StorageConfiguration>()
        ?? throw new InvalidOperationException("Storage configuration missing.");

    int storageTypeInt = StorageTypeHelper.ConvertStorageTypeToInt(config.StorageType);
    var cache = provider.GetService<IDistributedCache>();

    return storageTypeInt switch
    {
        1 => StorageServiceFactory.CreateLocalStorageService(config, cache),
        2 => ValidateLinodeConfig(config) ? StorageServiceFactory.CreateLinodeStorageService(config, cache) : throw new InvalidOperationException("Invalid Linode config"),
        3 => ValidateAwsConfig(config) ? StorageServiceFactory.CreateAwsStorageService(config, cache) : throw new InvalidOperationException("Invalid AWS config"),
        4 => ValidateNextcloudConfig(config) ? StorageServiceFactory.CreateNextCloudStorageService(config, new WebDavClient(), new HttpClient(), cache) : throw new InvalidOperationException("Invalid Nextcloud config"),
        5 => ValidateCloudflareConfig(config) ? StorageServiceFactory.CreateCloudflareStorageService(config, cache) : throw new InvalidOperationException("Invalid Cloudflare config"),  // ✅ ADD THIS LINE
        _ => throw new ArgumentException($"Unsupported storage type: {config.StorageType}")
    };
});

bool ValidateAwsConfig(StorageConfiguration c) => !string.IsNullOrEmpty(c.AWS?.AccessKey) && !string.IsNullOrEmpty(c.AWS.SecretKey) && !string.IsNullOrEmpty(c.AWS.Region) && !string.IsNullOrEmpty(c.AWS.BucketName);
bool ValidateLinodeConfig(StorageConfiguration c) => !string.IsNullOrEmpty(c.Linode?.AccessKey) && !string.IsNullOrEmpty(c.Linode.SecretKey) && !string.IsNullOrEmpty(c.Linode.S3Endpoint) && !string.IsNullOrEmpty(c.Linode.BucketName);
bool ValidateNextcloudConfig(StorageConfiguration c) => !string.IsNullOrEmpty(c.Nextcloud?.Username) && !string.IsNullOrEmpty(c.Nextcloud.Password) && !string.IsNullOrEmpty(c.Nextcloud.BaseUrl);
bool ValidateCloudflareConfig(StorageConfiguration c) => !string.IsNullOrEmpty(c.Cloudflare?.AccountId) && !string.IsNullOrEmpty(c.Cloudflare.AccessKey) && !string.IsNullOrEmpty(c.Cloudflare.SecretKey) && !string.IsNullOrEmpty(c.Cloudflare.BucketName);  // ✅ ADD THIS LINE


// -------------------------------
// HTTP CLIENT
// -------------------------------
builder.Services.AddHttpClient();

// After builder.Services...
builder.Services.AddRouting(options =>
{
    options.LowercaseUrls = true;
});

// -------------------------------
// IDENTITY
// -------------------------------
services.AddScoped<IUserStore<AspNetUser>, UserStore<AspNetUser, AspNetRole, ApplicationDbContext, uint>>();
services.AddScoped<IRoleStore<AspNetRole>, RoleStore<AspNetRole, ApplicationDbContext, uint>>();
services.AddScoped<UserManager<AspNetUser>, UserManager<AspNetUser>>();
services.AddScoped<RoleManager<AspNetRole>, RoleManager<AspNetRole>>();
services.AddScoped<SignInManager<AspNetUser>, SignInManager<AspNetUser>>();

// -------------------------------
// APP SERVICES
// -------------------------------
services.AddScoped<IMediaService, MediaService>();
services.AddNobiinDictionaryRepositories(builder.Configuration);
services.AddNobiinDictionaryServices();

services.AddScoped<IClaudeService, ClaudeService>();
services.AddScoped<IAudioPronunciationGeneratorService, AudioPronunciationGeneratorService>();
services.AddScoped<IFFmpegService, FFmpegService>();
services.AddScoped<IIPAAudioGeneratorService, IPAAudioGeneratorService>();
services.AddScoped<ISpeechToTextService, SpeechToTextService>();
services.AddScoped<IAlphabetAudioService, AlphabetAudioService>();
services.AddScoped<ITextToSpeechService, TextToSpeechService>();
services.AddScoped< ISpellCheckService, EnhancedSpellCheckService>();



services.AddAutoMapper(cfg => cfg.AddMaps(typeof(Program).Assembly));

// -------------------------------
// SECURITY: RATE LIMITING
// -------------------------------
services.AddRateLimiter(options =>
{
    // Per-IP: 1 submission every 7 seconds, burst of 2
    options.AddPolicy("ip-submission", httpContext =>
        RateLimitPartition.GetTokenBucketLimiter(
            httpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown",
            _ => new TokenBucketRateLimiterOptions
            {
                TokenLimit = 2,
                ReplenishmentPeriod = TimeSpan.FromSeconds(7),
                TokensPerPeriod = 1,
                AutoReplenishment = true,
                QueueLimit = 0
            }));

    // Global: 120 per minute
    options.AddPolicy("global-submission", _ =>
        RateLimitPartition.GetFixedWindowLimiter(
            "global",
            _ => new FixedWindowRateLimiterOptions
            {
                PermitLimit = 120,
                Window = TimeSpan.FromMinutes(1),
                QueueLimit = 0
            }));

    options.RejectionStatusCode = 429;
    options.OnRejected = (context, token) =>
    {
        context.HttpContext.Response.Headers["Retry-After"] = "7";
        return ValueTask.CompletedTask;
    };
});

// -------------------------------
// SECURITY: AUDIO VALIDATION + CAPTCHA + FINGERPRINT
// -------------------------------
services.AddScoped<AudioValidationService>();
//services.AddScoped<HCaptchaService>();
services.AddScoped<CloudflareTurnstileService>();
services.AddScoped<FingerprintTrackingService>();  // ← ADD THIS LINE

// -------------------------------
// BUILD APP
// -------------------------------
var app = builder.Build();

// -------------------------------
// MIDDLEWARE PIPELINE
// -------------------------------
#if DEBUG
app.UseOpenApi();
app.UseSwaggerUi();
#endif

app.UseHttpsRedirection();
app.UseCors();

app.UseMiddleware<LogContextMiddleware>()
   .UseMiddleware<RequestLogging>();
app.UseMiddleware<CustomErrorHandler>();
app.UseSerilogRequestLogging();

app.UseRouting();
// RATE LIMITING BEFORE AUTH & CaptchaValidationMiddleware

app.UseRateLimiter();

//Add the middleware to your pipeline. The middleware must be added AFTER UseRouting() but BEFORE UseAuthentication().
app.UseMiddleware<CaptchaValidationMiddleware>();


app.UseAuthentication();
app.UseAuthorization();

app.MapControllers();
app.MapHealthChecks("Health", new HealthCheckOptions
{
    ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse
});

app.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");

app.UseForwardedHeaders(new ForwardedHeadersOptions
{
    ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto
});

var hubBaseRoute = configuration["JwtSettings:hubOptions:baseRoute"];
app.MapHub<MainHub>($"{hubBaseRoute}/{MainHub.HubName}");

// -------------------------------
// RUN
// -------------------------------


app.Run();

// -------------------------------
// FORBIDDEN HANDLER (KEEP AT END)
// -------------------------------
namespace NobiinDictionary.App
{
    public class ForbiddenAuthorizationMiddlewareResultHandler : IAuthorizationMiddlewareResultHandler
    {
        private readonly AuthorizationMiddlewareResultHandler defaultHandler = new();

        public async Task HandleAsync(RequestDelegate next, HttpContext context, AuthorizationPolicy policy, PolicyAuthorizationResult authorizeResult)
        {
            if (authorizeResult.Forbidden)
            {
                var failureReasons = authorizeResult.AuthorizationFailure?.FailureReasons.FirstOrDefault();
                var failMessage = failureReasons?.Message ?? "Forbidden";
                context.Response.Clear();
                context.Response.StatusCode = 403;
                if (context.Response.Body.CanWrite)
                {
                    var bytes = Encoding.UTF8.GetBytes(failMessage);
                    await context.Response.BodyWriter.AsStream().WriteAsync(bytes);
                }
                return;
            }

            await defaultHandler.HandleAsync(next, context, policy, authorizeResult);
        }
    }
}